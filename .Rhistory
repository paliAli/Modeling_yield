# Run the model 10000 times for each k
for(i in 1:nrow(prior)){
# Define the parameters of the model
Pars <- c(k = prior$k[i])
# Run the model for the parameter set and make a data frame of the output
out <- rk4(y = State, times = time, func = LinearModel, parms = pars)
out <- as.data.frame(out)
# adjusting the name of out to match the data
colnames(out) <- c("years","prediction")
# Step 3.3: Join the prediction of the model for each data point
Errors <- merge(measurements, out, by.x = "years")
# Step 3.4: Compute the probability of observing each data point, given the model and the measurement uncertainty, assuming a normal (gaussian) distribution of errors
Errors$probability <- dnorm(Errors$measured, mean = Errors$prediction, sd = Errors$sd)
# Step 3.5: Compute the likelihood for each parameter set (the product of all individual probabilities)
prior$likelihood[i] <- prod(Errors$probability)
}
View(prior)
View(prior)
#Lmax<-prod(dnorm(x=measurements$y,mean=measurements$y,sd=measurements$sd)) #computing the maximum possible likelihood with the current sample
Lmax <- max(prior$likelihood)
# Run the model 10000 times for each k
for(i in 1:nrow(prior)){
# Define the parameters of the model
pars <- c(k = prior$k[i])
# Run the model for the parameter set and make a data frame of the output
out <- rk4(y = State, times = time, func = LinearModel, parms = pars)
out <- as.data.frame(out)
# adjusting the name of out to match the data
colnames(out) <- c("years","prediction")
# Step 3.3: Join the prediction of the model for each data point
Errors <- merge(measurements, out, by.x = "years")
# Step 3.4: Compute the probability of observing each data point, given the model and the measurement uncertainty, assuming a normal (gaussian) distribution of errors
Errors$probability <- dnorm(Errors$measured, mean = Errors$prediction, sd = Errors$sd)
# Step 3.5: Compute the likelihood for each parameter set (the product of all individual probabilities)
prior$likelihood[i] <- prod(Errors$probability)
}
#Lmax<-prod(dnorm(x=measurements$y,mean=measurements$y,sd=measurements$sd)) #computing the maximum possible likelihood with the current sample
Lmax <- max(prior$likelihood)
View(prior)
prior$likelihoodRel <- prior$likelihood/Lmax # compute the relative likelihood for each parameters set
prior$Accept <- FALSE
prior$Accept[ ( runif(nrow(prior)) < prior$likelihoodRel )]<-TRUE # create a random number between 1 and 0 for each parameter set, and accept it if the random number is smaller than the relative likelihood
posteriorAR <- prior[prior$Accept,]
View(posteriorAR)
for(i in 1: nrow(posteriorAR)){
# Define the initial state of the system for one sample
State <- c(C = Cini)
# Define the parameters of the model
pars <- c(slope = posteriorAR$k[i])
# Run the model for the parameter set and make a data frame of the output for one sample
out <- rk4(y = State, times = time, func = LinearModel, parms = pars)
# Assign the ID of the sample to the output and join the output to the posterior data frame
OneSample <- as.data.frame(out)
colnames(OneSample) <- c("years","prediction")
OneSample$id <- i
if(i == 1){posteriorData <- OneSample}else{
posteriorData <- rbind(posteriorData,OneSample)
}
}
View(posteriorAR)
#plot all samples from the posterior
ggplot(measurements, aes(years, measured)) +
geom_point() +
theme_classic() +
coord_cartesian(xlim = c(0, 4), ylim = c(0, 4))+
geom_line(data = posteriorData, aes(x = years, y = prediction, group = id),alpha=0.1, color ="blue")+
xlab("years")
View(measurements)
View(posteriorData)
View(measurements)
View(posteriorData)
#plot all samples from the posterior
ggplot(measurements, aes(years, measured)) +
geom_point() +
theme_classic() +
coord_cartesian(xlim = c(0, 4), ylim = c(0, 4))+
geom_line(data = posteriorData, aes(x = years, y = prediction, group = id),alpha=0.1, color ="blue")+
xlab("years")
#plot all samples from the posterior
ggplot(measurements, aes(years, measured)) +
geom_point() +
theme_classic() +
coord_cartesian(xlim = c(0, 4), ylim = c(0, 4))+
geom_line(data = posteriorData, aes(x = years, y = prediction, group = id),alpha=0.1, color ="blue")+
xlab("years")
#plot all samples from the posterior
ggplot(measurements, aes(years, measured)) +
geom_point() +
theme_classic() +
# coord_cartesian(xlim = c(0, 4), ylim = c(0, 4))+
geom_line(data = posteriorData, aes(x = years, y = prediction, group = id),alpha=0.1, color ="blue")+
xlab("years")
View(posteriorAR)
View(prior)
# Initial values ----
# Create measurement data frame
measurements <- data.frame(years = c(1, 2, 3, 4), measured = c(55, 28, 16, 7))
measurements$sd <- 5
# Define the model
LinearModel <- function(Time, State, Pars){
with(as.list(c(State, Pars)),{
dC <- -k * C
return(list(c(dC)))
})
}
# Define the time step
time <- seq(0, 5, 0.2)
# Define the initial value
Cini <- 100
State <- c(C = Cini)
# Define the parameres
k <- -.5
pars <- k
# Run the model
out <- rk4(y = State, times = time, func = LinearModel, parms = pars)
# Sampling step ----
SizeOfPrior <- 10000
# Create 10000 random values of k
prior <- data.frame(k = rnorm(n = SizeOfPrior, mean = 1, sd = .5))
# Creating empty columns for to store the probabilities, likelihoods and the predictions
prior$likelihood <- NA
measurements$probability <- NA
# Run the model 10000 times for each k
for(i in 1:nrow(prior)){
# Define the parameters of the model
pars <- c(k = prior$k[i])
# Run the model for the parameter set and make a data frame of the output
out <- rk4(y = State, times = time, func = LinearModel, parms = pars)
out <- as.data.frame(out)
# adjusting the name of out to match the data
colnames(out) <- c("years","prediction")
# Step 3.3: Join the prediction of the model for each data point
Errors <- merge(measurements, out, by.x = "years")
# Step 3.4: Compute the probability of observing each data point, given the model and the measurement uncertainty, assuming a normal (gaussian) distribution of errors
Errors$probability <- dnorm(Errors$measured, mean = Errors$prediction, sd = Errors$sd)
# Step 3.5: Compute the likelihood for each parameter set (the product of all individual probabilities)
prior$likelihood[i] <- prod(Errors$probability)
}
#Lmax<-prod(dnorm(x=measurements$y,mean=measurements$y,sd=measurements$sd)) #computing the maximum possible likelihood with the current sample
Lmax <- max(prior$likelihood)
prior$likelihoodRel <- prior$likelihood/Lmax # compute the relative likelihood for each parameters set
prior$Accept <- FALSE
prior$Accept[ ( runif(nrow(prior)) < prior$likelihoodRel )]<-TRUE # create a random number between 1 and 0 for each parameter set, and accept it if the random number is smaller than the relative likelihood
posteriorAR <- prior[prior$Accept,]
for(i in 1: nrow(posteriorAR)){
# Define the initial state of the system for one sample
State <- c(C = Cini)
# Define the parameters of the model
pars <- c(slope = posteriorAR$k[i])
# Run the model for the parameter set and make a data frame of the output for one sample
out <- rk4(y = State, times = time, func = LinearModel, parms = pars)
# Assign the ID of the sample to the output and join the output to the posterior data frame
OneSample <- as.data.frame(out)
colnames(OneSample) <- c("years","prediction")
OneSample$id <- i
if(i == 1){posteriorData <- OneSample}else{
posteriorData <- rbind(posteriorData,OneSample)
}
}
#plot all samples from the posterior
ggplot(measurements, aes(years, measured)) +
geom_point() +
theme_classic() +
# coord_cartesian(xlim = c(0, 4), ylim = c(0, 4))+
geom_line(data = posteriorData, aes(x = years, y = prediction, group = id),alpha=0.1, color ="blue")+
xlab("years")
posteriorAR$k
View(posteriorData)
for(i in 1: nrow(posteriorAR)){
# Define the initial state of the system for one sample
State <- c(C = Cini)
# Define the parameters of the model
pars <- c(k = posteriorAR$k[i])
# Run the model for the parameter set and make a data frame of the output for one sample
out <- rk4(y = State, times = time, func = LinearModel, parms = pars)
# Assign the ID of the sample to the output and join the output to the posterior data frame
OneSample <- as.data.frame(out)
colnames(OneSample) <- c("years","prediction")
OneSample$id <- i
if(i == 1){posteriorData <- OneSample}else{
posteriorData <- rbind(posteriorData,OneSample)
}
}
#plot all samples from the posterior
ggplot(measurements, aes(years, measured)) +
geom_point() +
theme_classic() +
# coord_cartesian(xlim = c(0, 4), ylim = c(0, 4))+
geom_line(data = posteriorData, aes(x = years, y = prediction, group = id),alpha=0.1, color ="blue")+
xlab("years")
#plot all samples from the posterior
ggplot(measurements, aes(years, measured)) +
geom_point() +
theme_classic() +
coord_cartesian(xlim = c(0, 4), ylim = c(0, 4))+
geom_line(data = posteriorData, aes(x = years, y = prediction, group = id),alpha=0.1, color ="blue")+
xlab("years")
#plot all samples from the posterior
ggplot(measurements, aes(years, measured)) +
geom_point() +
theme_classic() +
#coord_cartesian(xlim = c(0, 4), ylim = c(0, 4))+
geom_line(data = posteriorData, aes(x = years, y = prediction, group = id),alpha=0.1, color ="blue")+
xlab("years")
#plot all samples from the posterior
ggplot(measurements, aes(years, measured)) +
theme_classic() +
#coord_cartesian(xlim = c(0, 4), ylim = c(0, 4))+
geom_line(data = posteriorData, aes(x = years, y = prediction, group = id),alpha=0.1, color ="blue")+
geom_point() +
xlab("years")
source("~/GitHub/Modeling_yield/Scripts/Biomass_production.R", echo=TRUE)
# Import the csvs as data frames
biomass_files <- list.files(path = "Output", pattern = "biomass_production_", full.names = TRUE)
biomass_data <- lapply(biomass_files, read.csv)
test <- biomass_data[[1]]
# Plot the results ----
ggplot(test, aes(x = time)) +
geom_line(aes(y = WLV, color = "Leaf weight"), linewidth = 1.2) +
geom_line(aes(y = WST, color = "Stem weight"), linewidth = 1.2) +
geom_line(aes(y = WRT, color = "Root weight"), linewidth = 1.2) +
geom_line(aes(y = WSO, color = "Storage weight"), linewidth = 1.2) +
labs(title = "Biomass Production Over Time",
x = "Time",
y = "Weight (kg/ha)") +
scale_color_manual(values = c("Leaf weight" = "green",
"Stem weight" = "brown",
"Root weight" = "blue",
"Storage weight" = "orange")) +
theme(axis.ticks = element_line(linetype = "blank"),
axis.text.x = element_text(size = 0)) +
theme_minimal()
View(DVS_weather)
source("~/GitHub/Modeling_yield/Scripts/Biomass_production.R", echo=TRUE)
# Run the model for each location ----
# Loop the ode function through each weather subset for the growing season
for (i in 1:length(Unique_ID)) {
weather_subset <- DVS_weather[DVS_weather$ID == Unique_ID[i],]
# Find sowing dates
sowing_dates <- find_sowing_date(weather_subset)
for (sowing_date in sowing_dates) {
weather_subset_filtered <- weather_subset[weather_subset$Date >= sowing_date,]
# Define the growing season length
growing_season_length <- sum(weather_subset_filtered$DVS_stage <= 3)
# Define event times
event_times <- seq(1, nrow(weather_subset_filtered), by = growing_season_length)
# Define event data
event_data <- data.frame(var = c("WLV", "WST", "WRT", "WSO", "LAI"),
time = event_times,
value = c(1, 1, 1, 0, 0.1),
method = "replace")
# Run the ODE solver with events
out <- ode(y = state, times = times, func = crop_growth, parms = crop,
events = list(data = event_data, func = eventfun))
# Convert output to a data frame
out_df <- as.data.frame(out)
# Save the output
write.csv(out_df, paste0("Output/biomass_production_", Unique_ID[i], "_", sowing_date, ".csv"), row.names = FALSE)
}
}
View(DVS_weather)
class(DVS_weather$Date)
# Convert DVS_weather$Date to Date format
DVS_weather$Date <- as.Date(DVS_weather$Date, format = "%Y-%m-%d")
# Run the model for each location ----
# Loop the ode function through each weather subset for the growing season
for (i in 1:length(Unique_ID)) {
weather_subset <- DVS_weather[DVS_weather$ID == Unique_ID[i],]
# Find sowing dates
sowing_dates <- find_sowing_date(weather_subset)
for (sowing_date in sowing_dates) {
weather_subset_filtered <- weather_subset[weather_subset$Date >= sowing_date,]
# Define the growing season length
growing_season_length <- sum(weather_subset_filtered$DVS_stage <= 3)
# Define event times
event_times <- seq(1, nrow(weather_subset_filtered), by = growing_season_length)
# Define event data
event_data <- data.frame(var = c("WLV", "WST", "WRT", "WSO", "LAI"),
time = event_times,
value = c(1, 1, 1, 0, 0.1),
method = "replace")
# Run the ODE solver with events
out <- ode(y = state, times = times, func = crop_growth, parms = crop,
events = list(data = event_data, func = eventfun))
# Convert output to a data frame
out_df <- as.data.frame(out)
# Save the output
write.csv(out_df, paste0("Output/biomass_production_", Unique_ID[i], "_", sowing_date, ".csv"), row.names = FALSE)
}
}
data.frame(var = c("WLV", "WST", "WRT", "WSO", "LAI"),
time = event_times,
value = c(1, 1, 1, 0, 0.1),
method = "replace")
# Run the model for each location ----
# Loop the ode function through each weather subset for the growing season
for (i in 1:length(Unique_ID)) {
weather_subset <- DVS_weather[DVS_weather$ID == Unique_ID[i],]
# Find sowing dates
sowing_dates <- find_sowing_date(weather_subset)
for (sowing_date in sowing_dates) {
weather_subset_filtered <- weather_subset[weather_subset$Date >= sowing_date,]
# Define the growing season length
growing_season_length <- sum(weather_subset_filtered$DVS_stage <= 3)
# Define event times
event_times <- seq(1, nrow(weather_subset_filtered), by = growing_season_length)
# Run the ODE solver with events
out <- ode(y = state, times = times, func = crop_growth, parms = crop,
events = list(func = eventfun, time = event_times))
# Convert output to a data frame
out_df <- as.data.frame(out)
# Save the output
write.csv(out_df, paste0("Output/biomass_production_", Unique_ID[i], "_", sowing_date, ".csv"), row.names = FALSE)
}
}
# Run the model for each location ----
# Loop the ode function through each weather subset for the growing season
for (i in 1:length(Unique_ID)) {
weather_subset <- DVS_weather[DVS_weather$ID == Unique_ID[i],]
# Find sowing dates
sowing_dates <- find_sowing_date(weather_subset)
for (sowing_date in sowing_dates) {
weather_subset_filtered <- weather_subset[weather_subset$Date >= sowing_date,]
# Define the growing season length
growing_season_length <- sum(weather_subset_filtered$DVS_stage <= 3)
# Define event times
event_times <- seq(1, nrow(weather_subset_filtered), by = growing_season_length)
event_times <- event_times[event_times <= max(times)]  # Ensure within range
# Run the ODE solver with events
out <- ode(y = state, times = times, func = crop_growth, parms = crop,
events = list(func = eventfun, time = event_times))
# Convert output to a data frame
out_df <- as.data.frame(out)
# Save the output
write.csv(out_df, paste0("Output/biomass_production_", Unique_ID[i], "_", sowing_date, ".csv"), row.names = FALSE)
}
}
any(is.na(DVS_weather))
which(is.na(DVS_weather))
# Import the event function
source("Input_data/Event_function.R")
# Run the model for each location ----
# Loop the ode function through each weather subset for the growing season
for (i in 1:length(Unique_ID)) {
weather_subset <- DVS_weather[DVS_weather$ID == Unique_ID[i],]
# Find sowing dates
sowing_dates <- find_sowing_date(weather_subset)
for (sowing_date in sowing_dates) {
weather_subset_filtered <- weather_subset[weather_subset$Date >= sowing_date,]
# Define the growing season length
growing_season_length <- sum(weather_subset_filtered$DVS_stage <= 3)
# Define event times
event_times <- seq(1, nrow(weather_subset_filtered), by = growing_season_length)
event_times <- event_times[event_times <= max(times)]  # Ensure within range
# Run the ODE solver with events
out <- ode(y = state, times = times, func = crop_growth, parms = crop,
events = list(func = eventfun, time = event_times))
# Convert output to a data frame
out_df <- as.data.frame(out)
# Save the output
write.csv(out_df, paste0("Output/biomass_production_", Unique_ID[i], "_", sowing_date, ".csv"), row.names = FALSE)
}
}
# Run the model for each location ----
# Loop the ode function through each weather subset for the growing season
for (i in 1:length(Unique_ID)) {
weather_subset <- DVS_weather[DVS_weather$ID == Unique_ID[i],]
# Find sowing dates
sowing_dates <- find_sowing_date(weather_subset)
for (sowing_date in sowing_dates) {
weather_subset_filtered <- weather_subset[weather_subset$Date >= sowing_date,]
# Define the growing season length
growing_season_length <- sum(weather_subset_filtered$DVS_stage <= 3)
# Define event times
event_times <- seq(1, nrow(weather_subset_filtered), by = growing_season_length)
event_times <- event_times[event_times <= max(times)]  # Ensure within range
# Run the ODE solver with events
out <- ode(y = state, times = times, func = crop_growth, parms = crop,
events = list(func = eventfun, time = event_times))
# Convert output to a data frame
out_df <- as.data.frame(out)
# Save the output
write.csv(out_df, paste0("Output/biomass_production_", Unique_ID[i], "_", sowing_date, ".csv"), row.names = FALSE)
}
}
# Run the model for each location ----
# Loop the ode function through each weather subset for the growing season
for (i in 1:length(Unique_ID)) {
weather_subset <- DVS_weather[DVS_weather$ID == Unique_ID[i],]
# Find sowing dates
sowing_dates <- find_sowing_date(weather_subset)
for (sowing_date in sowing_dates) {
weather_subset_filtered <- weather_subset[weather_subset$Date >= sowing_date,]
# Define the growing season length
growing_season_length <- sum(weather_subset_filtered$DVS_stage <= 3)
# Define event times
event_times <- seq(1, nrow(weather_subset_filtered), by = growing_season_length)
event_times <- event_times[event_times <= max(times)]  # Ensure within range
# Run the ODE solver with events
out <- ode(y = state, times = times, func = crop_growth, parms = crop,
events = list(func = eventfun, time = event_times))
# Convert output to a data frame
out_df <- as.data.frame(out)
# Save the output
write.csv(out_df, paste0("Output/biomass_production_", Unique_ID[i], "_", sowing_date, ".csv"), row.names = FALSE)
}
}
# Run the model for each location ----
# Loop the ode function through each weather subset for the growing season
for (i in 1:length(Unique_ID)) {
weather_subset <- DVS_weather[DVS_weather$ID == Unique_ID[i],]
# Find sowing dates
sowing_dates <- find_sowing_date(weather_subset)
for (sowing_date in sowing_dates) {
weather_subset_filtered <- weather_subset[weather_subset$Date >= sowing_date,]
# Define the growing season length
growing_season_length <- sum(weather_subset_filtered$DVS_stage <= 3)
# Define event times
event_times <- seq(1, nrow(weather_subset_filtered), by = growing_season_length)
event_times <- event_times[event_times <= max(times)]  # Ensure within range
# Define the timestep
timestep <- 1 # Each day
# Define the time points for the ODE solver
times <- seq(1, nrow(weather_subset_filtered), by = timestep)  # Daily time steps
# Run the ODE solver with events
out <- ode(y = state, times = times, func = crop_growth, parms = crop,
events = list(func = eventfun, time = event_times))
# Convert output to a data frame
out_df <- as.data.frame(out)
# Save the output
write.csv(out_df, paste0("Output/biomass_production_", Unique_ID[i], "_", sowing_date, ".csv"), row.names = FALSE)
}
}
weather_subset_filtered <- weather_subset[weather_subset$Date >= sowing_date,]
View(weather_subset_filtered)
sowing_dates <- find_sowing_date(weather_subset)
sowing_dates
# Function to find the sowing date for a weather subset
find_sowing_date <- function(weather_data) {
# Extract the unique years in the weather data
unique_years <- unique(weather_data$YEAR)
# Initialize an empty vector to store sowing dates
sowing_dates <- c()
# Loop through each year to find the closest date to September 30
for (year in unique_years) {
# Define the target sowing date (first of October)
target_date <- as.Date(paste0(year, "-10-01"))
# Find the closest available date in the weather data
available_dates <- weather_data$Date
closest_date <- available_dates[which.min(abs(available_dates - target_date))]
# Store the closest sowing date
sowing_dates <- c(sowing_dates, closest_date)
}
return(sowing_dates)
}
# Function to find the sowing date for a weather subset
find_sowing_date <- function(weather_data) {
# Extract the unique years in the weather data
unique_years <- unique(weather_data$YEAR)
# Initialize an empty vector to store sowing dates
sowing_dates <- c()
# Loop through each year to find the closest date to September 30
for (year in unique_years) {
# Define the target sowing date (first of October)
target_date <- as.Date(paste0(YEAR, "-10-01"))
# Find the closest available date in the weather data
available_dates <- weather_data$Date
closest_date <- available_dates[which.min(abs(available_dates - target_date))]
# Store the closest sowing date
sowing_dates <- c(sowing_dates, closest_date)
}
return(sowing_dates)
}
for (i in 1:length(Unique_ID)) {
weather_subset <- DVS_weather[DVS_weather$ID == Unique_ID[i],]
# Find sowing dates
sowing_dates <- find_sowing_date(weather_subset)
# Run the model for each location ----
# Loop the ode function through each weather subset for the growing season
for (i in 1:length(Unique_ID)) {
weather_subset <- DVS_weather[DVS_weather$ID == Unique_ID[i],]
# Find sowing dates
sowing_dates <- find_sowing_date(weather_subset)
for (sowing_date in sowing_dates) {
weather_subset_filtered <- weather_subset[weather_subset$Date >= sowing_date,]
# Define the timestep
timestep <- 1 # Each day
# Define the number of time steps
num_steps <- nrow(weather_subset_filtered) # Number of observed days
# Define the time points for the ODE solver
times <- seq(1, num_steps, by = timestep)
# Define the growing season length
growing_season_length <- sum(weather_subset_filtered$DVS_stage <= 3)
# Define event times
event_times <- seq(1, nrow(weather_subset_filtered), by = growing_season_length)
event_times <- event_times[event_times <= max(times)]  # Ensure within range
# Run the ODE solver with events
out <- ode(y = state, times = times, func = crop_growth, parms = crop,
events = list(func = eventfun, time = event_times))
# Convert output to a data frame
out_df <- as.data.frame(out)
# Save the output
write.csv(out_df, paste0("Output/biomass_production_", Unique_ID[i], "_", sowing_date, ".csv"), row.names = FALSE)
}
}
for (i in 1:length(Unique_ID)) {
weather_subset <- DVS_weather[DVS_weather$ID == Unique_ID[i],]
# Find sowing dates
sowing_dates <- find_sowing_date(weather_subset)
sowing_dates <- find_sowing_date(weather_subset)
View(weather_subset)
View(weather_subset)
