source("~/GitHub/Modeling_yield/Scripts/DVS_calculation.R", echo=TRUE)
source("~/GitHub/Modeling_yield/Scripts/DVS_calculation.R", echo=TRUE)
# Load the required libraries ----
library(dplyr)
source("~/GitHub/Modeling_yield/Input_data/weather_data_2223.R", echo=TRUE)
# Load the required libraries ----
library(dplyr)
library(lubridate)
library(nasapower)
setwd("~/GitHub/Modeling_yield")
#load specific coordinates
source("Input_data/LowerResolution.R")
# This script resamples the map file to a lower resolution to make it feasible for the analysis
# The original map file is 100 x 100m, the resampled file is 1 x 1 km
source("Input_data/aggregated_landcover_raster_1x1km.tif")
install.packages(c("viridisLite", "ggpubr"), type= "binary")
install.packages("maptools", type= "binary")
# The original map file is 100 x 100m, the resampled file is 1 x 1 km
source("Input_data/aggregated_landcover_raster_1x1km.tif")
# The original map file is 100 x 100m, the resampled file is 1 x 1 km
source("Input_data/aggregated_landcover_raster_1x1km.tif")
map=raster("aggregated_landcover_raster_1x1km.tif")
source("~/GitHub/Modeling_yield/Input_data/LowerResolution.R", echo=TRUE)
install.packages(c("viridisLite", "ggpubr"), type = "binary")
map=raster("aggregated_landcover_raster_1x1km.tif")
library(raster)
map=raster("aggregated_landcover_raster_1x1km.tif")
map=raster("Input_data/aggregated_landcover_raster_1x1km.tif")
res(map)
crs(map)
plot(map)
# Define the aggregation factor (from 100m to 1km)
agg_factor <- 50
# Aggregate the raster using the modal function
aggregated_raster <- aggregate(map, fact = agg_factor, fun = modal)
# Save the aggregated raster
writeRaster(aggregated_raster, "aggregated_landcover_raster_50x50km.tif", format = "GTiff")
# Plot the aggregated raster
plot(aggregated_raster)
# Check the resolution of the resampled raster
res(aggregated_raster)
crs(aggregated_raster)
# Create a data frame with the aggregated raster values
df <- as.data.frame(aggregated_raster, xy = TRUE)
str(df)
unique(df$aggregated_landcover_raster_1x1km)
Wanted_Points<-df[df[,3] %in% c(12),]
plot(Wanted_Points$y~Wanted_Points$x, pch=20, col="red", xlab="X", ylab="Y", main="Wanted Points")
str(Wanted_Points)
# Rename the land use column
colnames(Wanted_Points)[3]<- "Land_Use"
# Replace 18 by Pastures and 26 by Natural grasslands
Wanted_Points$Land_Use[Wanted_Points$Land_Use==18]<- "Pastures"
Wanted_Points$Land_Use[Wanted_Points$Land_Use==26]<- "Natural grasslands"
Wanted_Points$Land_Use[Wanted_Points$Land_Use==22]<- "Agroforestry areas"
# Store the data frame in a CSV file
write.table(Wanted_Points, "../../Wanted_Grassland_Points10km.csv", row.names = FALSE,sep=";")
# Save the aggregated raster
writeRaster(aggregated_raster, "Input_data/aggregated_landcover_raster_50x50km.tif", format = "GTiff")
# Save the aggregated raster
writeRaster(aggregated_raster, "Input_data/aggregated_landcover_raster_50x50km.tif", format = "GTiff")
# Save the aggregated raster
writeRaster(aggregated_raster, "Input_data/aggregated_landcover_raster_50x50km.tif", format = "GTiff")
# Plot the aggregated raster
plot(aggregated_raster)
# Check the resolution of the resampled raster
res(aggregated_raster)
crs(aggregated_raster)
# Create a data frame with the aggregated raster values
df <- as.data.frame(aggregated_raster, xy = TRUE)
str(df)
unique(df$aggregated_landcover_raster_1x1km)
Wanted_Points<-df[df[,3] %in% c(12),]
plot(Wanted_Points$y~Wanted_Points$x, pch=20, col="red", xlab="X", ylab="Y", main="Wanted Points")
str(Wanted_Points)
# Rename the land use column
colnames(Wanted_Points)[3]<- "Land_Use"
# Replace 18 by Pastures and 26 by Natural grasslands
Wanted_Points$Land_Use[Wanted_Points$Land_Use==18]<- "Pastures"
Wanted_Points$Land_Use[Wanted_Points$Land_Use==26]<- "Natural grasslands"
Wanted_Points$Land_Use[Wanted_Points$Land_Use==22]<- "Agroforestry areas"
# Store the data frame in a CSV file
write.table(Wanted_Points, "Input_data/Wanted_Grassland_Points10km.csv", row.names = FALSE,sep=";")
source("~/GitHub/Modeling_yield/Input_data/weather_data_2223.R", echo=TRUE)
install.packages(c("viridisLite", "ggpubr"), type = "binary")
map=raster("Input_data/aggregated_landcover_raster_1x1km.tif")
res(map)
crs(map)
plot(map)
# Define the aggregation factor (from 100m to 1km)
agg_factor <- 50
# Aggregate the raster using the modal function
aggregated_raster <- aggregate(map, fact = agg_factor, fun = modal)
# Save the aggregated raster
writeRaster(aggregated_raster, "Input_data/aggregated_landcover_raster_50x50km.tif", format = "GTiff")
source("~/GitHub/Modeling_yield/Input_data/weather_data_2223.R", echo=TRUE)
install.packages(c("viridisLite", "ggpubr"), type = "binary")
map=raster("Input_data/aggregated_landcover_raster_1x1km.tif")
res(map)
crs(map)
plot(map)
# Define the aggregation factor (from 100m to 1km)
agg_factor <- 50
# Aggregate the raster using the modal function
aggregated_raster <- aggregate(map, fact = agg_factor, fun = modal)
# Save the aggregated raster
writeRaster(aggregated_raster, "Input_data/aggregated_landcover_raster_50x50km.tif", format = "GTiff")
read.table("Input_data/Wanted_Grassland_Points10km.csv")
# Create a data frame with the aggregated raster values
df <- as.data.frame(aggregated_raster, xy = TRUE)
str(df)
unique(df$aggregated_landcover_raster_1x1km)
Wanted_Points<-df[df[,3] %in% c(12),]
plot(Wanted_Points$y~Wanted_Points$x, pch=20, col="red", xlab="X", ylab="Y", main="Wanted Points")
latitudes <- Wanted_Points$y
longitudes <- Wanted_Points$x
# Define a sowing date and a harvest date
startDate <- "2022-01-01" # Change it to be the same as the growing season
endDate <- "2025-01-01"
dates <- c(startDate, endDate)
# Download the data from NASA POWER ----
Variables <- c("ALLSKY_SFC_SW_DWN", "PRECTOTCORR", "RH2M", "T2MDEW", "T2M_MAX", "T2M_MIN", "WS2M")
VarName <- c("Solar", "ppt", "RH", "Tdew", "Tmax", "Tmin", "windspeed")
# Download the data from NASA POWER
Europe_weather_data <- data.frame()
for (lat in latitudes) {
for (lon in longitudes) {
data <- nasapower::get_power(
community = "ag",
lonlat = c(lon, lat),
pars = Variables,
dates = dates,
temporal_api = "daily"
)
# Rename columns using VarName
names(data)[names(data) %in% Variables] <- VarName
Europe_weather_data <- rbind(Europe_weather_data, data)
}
}
# Edit the data frame ----
summary(Europe_weather_data)
class(Europe_weather_data$YYYYMMDD)
# Rename YYYYMMDD to date
colnames(Europe_weather_data)[colnames(Europe_weather_data) == "YYYYMMDD"] <- "Date"
# Calculate average temperature
Europe_weather_data <- Europe_weather_data %>%
mutate(
Tmean = (Tmax + Tmin) / 2
)
# Download the data from NASA POWER
Europe_weather_data <- data.frame()
for (lat in latitudes) {
for (lon in longitudes) {
data <- nasapower::get_power(
community = "ag",
lonlat = c(lon, lat),
pars = Variables,
dates = dates,
temporal_api = "daily"
)
# Rename columns using VarName
names(data)[names(data) %in% Variables] <- VarName
Europe_weather_data <- rbind(Europe_weather_data, data)
}
}
View(Wanted_Points)
View(Wanted_Points)
# Check the resolution of the resampled raster
res(aggregated_raster)
map=raster("Input_data/aggregated_landcover_raster_1x1km.tif")
res(map)
crs(map)
plot(map)
# Define the aggregation factor (from 100m to 1km)
agg_factor <- 50
# Aggregate the raster using the modal function
aggregated_raster <- aggregate(map, fact = agg_factor, fun = modal)
# Save the aggregated raster
writeRaster(aggregated_raster, "Input_data/aggregated_landcover_raster_50x50km.tif", format = "GTiff")
# Plot the aggregated raster
plot(aggregated_raster)
# Check the resolution of the resampled raster
res(aggregated_raster)
crs(aggregated_raster)
# Create a data frame with the aggregated raster values
df <- as.data.frame(aggregated_raster, xy = TRUE)
str(df)
unique(df$aggregated_landcover_raster_1x1km)
Wanted_Points<-df[df[,3] %in% c(12),]
plot(Wanted_Points$y~Wanted_Points$x, pch=20, col="red", xlab="X", ylab="Y", main="Wanted Points")
str(Wanted_Points)
# Rename the land use column
colnames(Wanted_Points)[3]<- "Land_Use"
# Replace 18 by Pastures and 26 by Natural grasslands
Wanted_Points$Land_Use[Wanted_Points$Land_Use==18]<- "Pastures"
Wanted_Points$Land_Use[Wanted_Points$Land_Use==26]<- "Natural grasslands"
Wanted_Points$Land_Use[Wanted_Points$Land_Use==22]<- "Agroforestry areas"
# Convert the coordinates from the raster CRS to geographic coordinates (WGS84) ----
# Create a SpatVector from the wanted points
wanted_points_vect <- vect(Wanted_Points[, 1:2], crs = crs(aggregated_raster))
library(terra)
aggregated_raster
# Convert the coordinates from the raster CRS to geographic coordinates (WGS84) ----
# Create a SpatVector from the wanted points
wanted_points_vect <- vect(Wanted_Points[, 1:2], crs = crs(aggregated_raster))
View(Wanted_Points)
# Convert the coordinates from the raster CRS to geographic coordinates (WGS84) ----
# Create a SpatVector from the wanted points
wanted_points_vect <- vect(Wanted_Points[, c("x", "y")], crs = crs(aggregated_raster))
View(Wanted_Points)
View(Wanted_Points)
# Convert the coordinates from the raster CRS to geographic coordinates (WGS84) ----
# Create a SpatVector from the wanted points
wanted_points_vect <- vect(Wanted_Points[, c("x", "y")], crs = crs(aggregated_raster))
str(Wanted_Points)
print(crs(aggregated_raster))
# Convert the coordinates from the raster CRS to geographic coordinates (WGS84) ----
# Set the CRS of the raster explicitly to EPSG:3035 (ETRS89 / LAEA Europe)
crs(aggregated_raster) <- "EPSG:3035"
# Create a SpatVector from the wanted points
wanted_points_vect <- vect(Wanted_Points[, c("x", "y")], crs = crs(aggregated_raster))
print(crs(aggregated_raster))
# Create a SpatVector from the wanted points
wanted_points_vect <- vect(Wanted_Points[, c("x", "y")], crs = "EPSG:3035")
is.na(Wanted_Points)
any(is.na(Wanted_Points))
# Reset row names
row.names(Wanted_Points) <- NULL
# Create a SpatVector from the wanted points
wanted_points_vect <- vect(Wanted_Points[, c("x", "y")], crs = "EPSG:3035")
# Obtain only the columns x and y from Wanted_points
Wanted_Points <- Wanted_Points[, c("x", "y")]
# Create a SpatVector from the wanted points
wanted_points_vect <- vect(Wanted_Points[, c("x", "y")], crs = "EPSG:3035")
?vect
# Ensure x and y columns are numeric
Wanted_Points$x <- as.numeric(Wanted_Points$x)
Wanted_Points$y <- as.numeric(Wanted_Points$y)
# Create a SpatVector from the wanted points
wanted_points_vect <- vect(Wanted_Points[, c("x", "y")], crs = "EPSG:3035")
library(rgdal)
install.packages("rgdal")
library(rgdal)
Wanted_Points<-df[df[,3] %in% c(12),]
str(Wanted_Points)
# Rename the land use column
colnames(Wanted_Points)[3]<- "Land_Use"
# Replace 18 by Pastures and 26 by Natural grasslands
Wanted_Points$Land_Use[Wanted_Points$Land_Use==18]<- "Pastures"
Wanted_Points$Land_Use[Wanted_Points$Land_Use==26]<- "Natural grasslands"
Wanted_Points$Land_Use[Wanted_Points$Land_Use==22]<- "Agroforestry areas"
# Convert the coordinates from the raster CRS to geographic coordinates (WGS84) ----
# Define the source and target CRS
source_crs <- "+proj=laea +lat_0=52 +lon_0=10 +x_0=4321000 +y_0=3210000 +ellps=GRS80 +units=m +no_defs"
target_crs <- "+proj=longlat +datum=WGS84 +no_defs"
# Convert the coordinates
coords <- as.data.frame(project(as.matrix(Wanted_Points[, c("x", "y")]), proj = target_crs, inv = TRUE))
View(Wanted_Points)
# Create a spatial object from the Wanted_Points data frame
coordinates(Wanted_Points) <- ~x + y
proj4string(Wanted_Points) <- source_crs
# Transform the coordinates to the target CRS (WGS84)
Wanted_Points_transformed <- spTransform(Wanted_Points, target_crs)
# Extract the transformed coordinates and add them back to the data frame
Wanted_Points$Longitude <- coordinates(Wanted_Points_transformed)[, 1]
Wanted_Points$Latitude <- coordinates(Wanted_Points_transformed)[, 2]
# Inspect the updated data frame
head(Wanted_Points)
# Plot the transformed points
plot(Wanted_Points$Latitude ~ Wanted_Points$Longitude,
pch = 20, col = "blue",
xlab = "Longitude", ylab = "Latitude",
main = "Wanted Points in WGS84")
View(Wanted_Points)
latitudes <- coords[,1]
coords <- coordinates(Wanted_Points)
latitudes <- coords[,1]
longitudes <- coords[,2]
latitudes
View(Wanted_Points)
latitudes <-  Wanted_points$Latitude
latitudes <-  Wanted_Points$Latitude
longitudes <- Wanted_Points$Longitude
# Define a sowing date and a harvest date
startDate <- "2022-01-01" # Change it to be the same as the growing season
endDate <- "2025-01-01"
dates <- c(startDate, endDate)
# Download the data from NASA POWER ----
Variables <- c("ALLSKY_SFC_SW_DWN", "PRECTOTCORR", "RH2M", "T2MDEW", "T2M_MAX", "T2M_MIN", "WS2M")
VarName <- c("Solar", "ppt", "RH", "Tdew", "Tmax", "Tmin", "windspeed")
# Download the data from NASA POWER
Europe_weather_data <- data.frame()
for (lat in latitudes) {
for (lon in longitudes) {
data <- nasapower::get_power(
community = "ag",
lonlat = c(lon, lat),
pars = Variables,
dates = dates,
temporal_api = "daily"
)
# Rename columns using VarName
names(data)[names(data) %in% Variables] <- VarName
Europe_weather_data <- rbind(Europe_weather_data, data)
}
}
View(Europe_weather_data)
# Edit the data frame ----
summary(Europe_weather_data)
class(Europe_weather_data$YYYYMMDD)
# Rename YYYYMMDD to date
colnames(Europe_weather_data)[colnames(Europe_weather_data) == "YYYYMMDD"] <- "Date"
# Calculate average temperature
Europe_weather_data <- Europe_weather_data %>%
mutate(
Tmean = (Tmax + Tmin) / 2
)
#save the data
write.csv(Europe_weather_data, "~/Github/Modeling_yield/Europe_weather_data.csv", row.names = FALSE)
#save the data
write.csv(Europe_weather_data, "Input_data/Europe_weather_data.csv", row.names = FALSE)
# Required libraries -----
library(ggplot2)
library(dplyr)
# Prepare the data ----
# Set working directory
setwd("~/GitHub/Modeling_yield")
# Load in crop data
source("Input_data/crop_data.R")
# Define crop TSUM thresholds ----
TSUM_stages <- c(crop$TSUMEM,crop$TSUMEM + crop$TSUM1, crop$TSUMEM + crop$TSUM1 + crop$TSUM2) # Cumulative TSUM values
DVS_stages <- c(0, 1, 2) # Corresponding development stages
# Import the weather data
weather <- read.csv("Input_data/Europe_weather_data.csv")
View(weather)
# Compute TSUM and DVS for each location
DVS_weather <- weather %>%
group_by(LON, LAT) %>%
arrange(Date) %>%
mutate(
TSUM = cumsum(Tmean), # calculate cumulative sum of temperatures
DVS_stage = approx(x = TSUM_stages, y = DVS_stages, xout = TSUM, rule = 2)$y # Interpolate DVS
) %>%
ungroup()
write.csv(DVS_weather, "Input_data/DVS_weather.csv", row.names = FALSE)
View(DVS_weather)
View(DVS_weather)
# Visualize the development stages
ggplot(data = DVS_weather, aes(x = DOY, y = DVS_stage, color = paste(LON, LAT))) +
geom_line() +
labs(title = "Development Stages (DVS) Over Time",
x = "DOY",
y = "Development Stage (DVS)") +
theme_minimal() +
theme(legend.position = "none") # Remove legend for clarity
# Create a identifier column for the weather
DVS_weather$ID <- paste0(DVS_weather$LON, "_", DVS_weather$LAT)
Unique_ID <- unique(DVS_weather$ID)
# Required libraries ----
library(deSolve)
# Load in crop data
source("Input_data/crop_data.R")
# Import the weather data ----
source("Scripts/DVS_calculation.R")
# Initial states ----
initial_leaf_weight <- 0.1
initial_stem_weight <- 0.1
initial_root_weight <- 0.1
initial_storage_weight <- 0
initial_LAI <- 0.1
state <- c(WLV = initial_leaf_weight,
WST = initial_stem_weight,
WRT = initial_root_weight,
WSO = initial_storage_weight,
LAI = initial_LAI)
any(is.na(DVS_weather))
which(is.na(DVS_weather))
# Remove NAs from the weather dataset
DVS_weather <- DVS_weather[complete.cases(DVS_weather), ]
any(is.na(DVS_weather))
# Define the model ----
crop_growth <- function(t, state, parameters){
with(as.list(c(state, crop)),{
# Get current weather values
day <- floor(t)
Tmean <- weather_subset$Tmean[day]
SR <- weather_subset$Solar[day]
DVS_now <- weather_subset$DVS_stage[day]
LAI_now <- state["LAI"]
if (any(is.na(c(Tmean, SR, DVS_now, LAI_now)))) {
stop("NA values in weather data or state vector")
}
# Calculate required variables
# Convert total radiation to PAR
PAR <- 0.5 * SR  # About 50% of incoming radiation is PAR (Photosynthetically Active Radiation)
# Intercepted PAR using Beerâ€™s Law
fPAR <- 1 - exp(-k * LAI_now)  # k = light extinction coefficient
# Simplified calculation of photosynthesis
Rd <- Ce * PAR * fPAR # gross assimilation in kg/ha/day
# Maintenance respiration
RM_25 <- WLV*RML + WST*RMS + WRT*RMR + WSO*RMO
RM <- RM_25 * Q10^((Tmean - 25)/10) # maintenance respiration in kg/ha/day
# Net biomass assimilation
if (RM > Rd) {
RM <- Rd # The maintenance respiration cannot exceed the gross assimilation
}
RN <- Rd - RM # net assimilation in kg/ha/day
print(paste("Rd:", Rd, "RM:", RM, "RN:", RN))
if (is.na(RN)) {
stop("RN is NA. Check Rd and RM.")
}
# Partitioning (interpolated from tables based on DVS)
FL <- approx(FLTB_df$DVS, FLTB_df$Value, xout = DVS_now, rule = 2)$y
FS <- approx(FSTB_df$DVS, FSTB_df$Value, xout = DVS_now, rule = 2)$y
FR <- approx(FRTB_df$DVS, FRTB_df$Value, xout = DVS_now, rule = 2)$y
FO <- approx(FOTB_df$DVS, FOTB_df$Value, xout = DVS_now, rule = 2)$y
# Biomass growth
dWLV <- RN * FL #* CVL I would use this if I want to calculate carbon content (?)
dWST <- RN * FS #* CVS
dWRT <- RN * FR #* CVR
dWSO <- RN * FO #* CVO
# LAI growth (based on SLA and max relative rate)
dLAI <- min(RGRLAI * LAI_now, SLA * dWLV) # SLA = specific leaf area in ha/kg
# Stop growth when RN is below a threshold and DVS reaches the end stage
if (RN < 0.01 & DVS_now == 3) {
return(NULL) # Stop simulation
}
return(list(
c(dWLV, dWST, dWRT, dWSO, dLAI),
Rd = Rd,
RN = RN,
DVS = DVS_now
))
})
}
# Run the model for each location ----
# Loop the ode function through each weather subset
for(i in 1:length(Unique_ID)) {
weather_subset <- DVS_weather[DVS_weather$ID == Unique_ID[i],]
# Define the time step
time_step <- 1 # in days
# Define the number of time steps
num_steps <- nrow(weather_subset) # Number of observed days
times <- seq(1, num_steps, by = time_step) # Time vector
# Run the model
out <- ode(y = state, times = times, func = crop_growth, parms = crop)
# Convert the output to a data frame
out_df <- as.data.frame(out)
# Save the output to a CSV file
write.csv(out_df, paste0("Output/biomass_production_", Unique_ID[i], ".csv"), row.names = FALSE)
}
# Import the csvs as data frames
biomass_files <- list.files(path = "Output", pattern = "biomass_production_", full.names = TRUE)
biomass_data <- lapply(biomass_files, read.csv)
View(biomass_data)
biomass_data[[1]]
test <- biomass_data[[1]]
# Plot the results ----
ggplot(test, aes(x = time)) +
geom_line(aes(y = WLV, color = "Leaf weight"), linewidth = 1.2) +
geom_line(aes(y = WST, color = "Stem weight"), linewidth = 1.2) +
geom_line(aes(y = WRT, color = "Root weight"), linewidth = 1.2) +
geom_line(aes(y = WSO, color = "Storage weight"), linewidth = 1.2) +
labs(title = "Biomass Production Over Time",
x = "Time",
y = "Weight (kg/ha)") +
scale_color_manual(values = c("Leaf weight" = "green",
"Stem weight" = "brown",
"Root weight" = "blue",
"Storage weight" = "orange")) +
theme(axis.ticks = element_line(linetype = "blank"),
axis.text.x = element_text(size = 0)) +
theme_minimal()
# Only plot LAI
ggplot(test, aes(x = time, y = LAI)) +
geom_line(color = "purple", linewidth = 1.2) +
labs(title = "Leaf Area Index (LAI) Over Time",
x = "Time",
y = "LAI") +
theme(axis.ticks = element_line(linetype = "blank"),
axis.text.x = element_text(size = 0)) +
theme_minimal()
